<template>
    <div>
        <div>
            <h4>TCP</h4>
            <p>
                前端网络连接经常会问：'从输入url地址到回车发生了什么？'
                经常会只记得三次握手和四次挥手。今天主要讲讲中间的 TCP 链接。
                感谢掘金作者
                <a href="https://juejin.im/post/5e527c58e51d4526c654bf41" target='_blank'>
                    神三元
                </a>技术分享
            </p>
            <ul>
                <li>1.DNS解析IP地址:先解析本地缓存记录有没有，没有就向服务器请求</li>
                <li>2.TCP三次握手建立连接：客户端向服务端相互发送报文，确立建立链接</li>
                <li>3.发送http请求：请求中包含访问的URL，KeepAlive，长连接，还有User-Agent用户浏览器操作系统信息，编码等。</li>
                <li>4.部分服务器会进行重定向</li>
                <li>5.服务器处理，返回http响应</li>
                <li>6.浏览器解析响应</li>
                <li>7.构建DOM、CSSOM树</li>
                <li>8.生成render树并绘制：浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了。</li>
            </ul>
        </div>
        <div>
            <h5>三次握手的过程？为什么是三次而不是两次、四次？</h5>
            <img src="@/assets/netWork/netcp01.jpg">
            <p>
                看上面的图片就可以看出，经过了三次的握手。
                首先是客户端向服务端发送一个SYN报文，请求建立连接。
                服务端收到报文确认后，发送一个SYN-ACK报文，表示确认收到请求。
                客户端收到服务器的报文后，返回一个ACK报文，连接建立。

                但是为什么是三次不是两次，是因为无法确认客户端的接收能力，
                需要再次确认。为什么不是四次是因为三次已经保证建立链接了，
                当然四次也可以，再多用处就不大了。
            </p>
        </div>
        <div>
            <h5>三次握手过程中可以携带数据么？</h5>
            <p>
                第三次握手的时候，可以携带。前两次握手不能携带数据。
                如果前两次握手能够携带数据，那么一旦有人想攻击服务器，
                那么他只需要在第一次握手中的 SYN 报文中放大量数据，
                那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。
                第三次握手的时候，客户端已经处于ESTABLISHED状态，
                并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。
            </p>
        </div>
        <div>
            <h5>TCP 四次挥手的过程</h5>
            <img src="@/assets/netWork/netcp02.jpg">
            <p>
                刚开始双方处于ESTABLISHED状态,客户端要断开了，向服务器发送 FIN 报文。
            </p>
            <ul>
                <li>发送后客户端变成了FIN-WAIT-1状态,即无法向服务端发送报文，只能接收。</li>
                <li>服务端接收后向客户端确认，变成了CLOSED-WAIT状态。</li>
                <li>客户端接收到了服务端的确认，变成了FIN-WAIT2状态。</li>
                <li>随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，</li>
                <li>客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。</li>
                <li>
                    等待 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间),没有收到服务端的重发请求，
                    那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。
                </li>
            </ul>
            <p>
                等待2MSL的意义:当服务端还有很多数据包要给客户端发还在传输过程中，
                若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。
                1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端。
                1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达
            </p>
        </div>
        <div>
            <h5>为什么是四次挥手而不是三次？</h5>
            <p>
                服务端将ACK和FIN的发送合并为一次挥手，
                这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，
                从而让客户端不断的重发FIN。
            </p>
        </div>
    </div>
</template>

<script>
export default {
    name:"linkTCP",
}
</script>

